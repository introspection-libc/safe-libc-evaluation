#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <netinet/ip.h>
#include <arpa/inet.h>

#define u8 uint8_t
#define u16 uint16_t

struct dns_header {
  u16 id;
  u8  hb3,hb4;
  u16 qdcount,ancount,nscount,arcount;
};


/* return zero if we can't answer from cache, or packet size if we can */
size_t answer_request(struct dns_header *header, char *limit, size_t qlen,  
		      struct in_addr local_addr, struct in_addr local_netmask, 
		      time_t now, int ad_reqd, int do_bit, int have_pseudoheader) 
{
#if 0 // avoid unused var warnings
  char *name = daemon->namebuff;
  unsigned char *p, *ansp;
  unsigned int qtype, qclass;
  struct all_addr addr;
  int nameoffset;
  unsigned short flag;
  int q, ans, anscount = 0, addncount = 0;
  int dryrun = 0;
  struct crec *crecp;
  int nxdomain = 0, auth = 1, trunc = 0, sec_data = 1;
  struct mx_srv_record *rec;
  size_t len;
#endif

  /* Clear buffer beyond request to avoid risk of
     information disclosure. */
#ifdef __CHKP__
  __safe_memset(((char *)header) + qlen, 0,
	 (limit - ((char *)header)) - qlen);
#else
  memset(((char *)header) + qlen, 0, 
	 (limit - ((char *)header)) - qlen);
#endif

  return 0;
}

int main(void)
{
	char buf[5131];
	struct dns_header* header = (struct dns_header*) buf;
	unsigned short udp_size = 0;
	size_t n = 368;
	struct in_addr local_addr = { 0 };
	struct in_addr local_netmask = { 0 };
	time_t now = { 0 };
	int ad_reqd = 0;
	int do_bit = 0;
	int have_pseudoheader = 0;
	printf("Overflow!\n");
	answer_request(header, ((char *) header) + udp_size, n, local_addr,
			local_netmask, now, ad_reqd, do_bit,
			have_pseudoheader);
	printf("Execution continues normally...\n");
	return 0;
}
